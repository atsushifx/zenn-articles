---
title: "Racket: Racketの基本データ型"
emoji: "🎾"
type: "idea"
topics: ["Racket", "関数型プログラミング", "データ型", ]
published: false
---

## はじめに

この記事では、`Racket`の基本データ型について詳しく説明します。
`Racket`は`LISP`に由来した関数型プログラミング言語であり、教育用として使われています。

## 1. Racketとは

`Racket`は、`Scheme`を拡張したプログラミング言語です。
`Racket`の設計は、とくに新しいプログラマが関数型プログラミングの概念を簡単に学べるようにすることを目的としています。

## 2. Racketのデータ型

`Racket`におけるデータ型の特徴として、動的データ型と不変性 ('immutable') があります。
動的データ型により、開発者は直感的なコーディングが可能になります。
型の宣言を気にせずデータを操作できるため、プロトタイピングや小規模プロジェクトでの開発が迅速に進められます。

一方で、不変性によりデータの意図しない変更を防ぐことができ、プログラムの信頼性を高めます。

## 2.1 動的データ型

`Racket`では、データ型を動的に扱います。これにより、プログラムは実行時にデータの型を柔軟に変更できます。

## 2.2 不変性 (immutable)

`Racket`では、データは基本的に不変 (`immutable`)です。
これは、一度作成したデータはその後、変更できないことを意味します。

たとえば、次のコードでのように変数 `x` の値を再定義しようとすると、エラーを引き起こします。

```racket: sample.rkt
(define x 10)
(println x)      ; 10
(define x 20)   ; xの値を、20に変更
(println x)

```

実行すると、下記のように`identifier already defined`エラーが発生します。

```racket: racket実行結果
module: identifier already defined
  at: x
```

値を上書きしたい場合は、下記のように`set!`を使用します:

```racket: sample2.rkt
(define x 10)
(println x)      ; 10
(set! x 20)   ; xの値を、20に変更
(println x)
```

## 3. Racketの基本データ型

`Racket`におけるデータ型は多岐にわたりますが、ここでは数値型、文字列型、ブーリアン型などの基本的なデータ型に焦点を当てて説明します。

### 3.1 数値型

`Racket`には整数型、有理数型、実数型の 3種類の数値型があり、型は`number`となります。
数値型は、プログラム中でさまざまな算術演算に使用されます。

たとえば、整数型を使って次のような簡単な算術演算を行なえます:

```racket: integer-calc.rkt
(define my-integer 42)
(+ my-integer 8)  ; 50

```

#### 不正確な数

特殊な数として、以下のシンボルが定義されています。

- `+inf.0`  : 正の無限大
- `-inf.0`  : 負の無限大
- `+nan.0` / `-nan.0`: 非数 (数値ではない)

### 3.2 整数型

整数型は、正負の整数および`0`を表現するために使用します。整数型の型は`integer`です。

```racket:my-integer.rkt
(define my-integer  42)

```

上記の例では、変数`my-integer`に `42` を代入しています。整数型には、以下のような算術演算子を使用できます。

- `+` : 加算
- `-` : 減算
- `*` : 乗算
- `/ : 除算
- `quotient`: 整数除算
- `remainder`: 余りの演算
- `modulo` : 剰余演算

`2進数`、`8進数`、`16進数`でも記述できます。
これらは、下記のように接頭辞 (`#b`,`#o`,`#x`) を付けて記述します。

- `2進数`: `#b1011` = `11`
- `8進数`: `#o15` = `13`
- `16進数`: `#xa3` = `163`

### 3.3 有理数型

有理数型は、分数を表現するために使用します。有理数型の型は`rational`です。

```racket: my-rational.rkt
(define my-rational 3/4)

```

上記の例では、変数`my-rational` に 3/4 を代入しています。有理数型には、以下のような算術演算子を使用できます。

- `+` : 加算
- `-` : 減算
- `*` : 乗算
- `/` : 除算

### 3.4 実数型

実数型は、小数点以下の桁数を持つ数を表現するために使用されます。実数型の型は、`float` または`real`です。

```racket: my-real.rkt
(define my-real 3.141592)

```

上記の例では、変数`my-real`に `3.141592` を代入しています。実数型には、以下のような算術演算子を使用できます。

- `+` : 加算
- `-` : 減算
- `*` : 乗算
- `/` : 除算

### 3.5 文字列型

文字列型は、文字列を表現するために使用され、型は`string`です。
文字列は、代入したい文字列`"`でくくります。
文字列型では、文字列の生成、連結、部分取得など、さまざまな文字列操作が可能です。

- `string-append` : 文字列を連結する
- `string-length` : 文字列の長さを取得する
- `string-ref`    : 文字列の指定した位置にある文字を取得する

下記のように、文字列を操作してメッセージを作成できます:

```racket: my-string.rkt
(define my-string "hello ")
(displayln (string-append my-string "world"))

```

### 3.6 文字型

文字型は、`Unicode`文字を表現するために使用され、文字型の型は`char`です。
文字型では、文字を`#\f`のように`#\<文字>`の形で記述します。

```racket: my-char.rkt
(define my-char #\あ)

my-char
#\あ

(char->integer my-char)
12354
```

上記の例では、変数 `my-char`に文字`あ`を代入しています。文字型には、以下のような比較演算子を使用できます。

- `char=?`  : 文字が等しいかどうかを比較する
- `char<?`  : 文字の大小関係を比較する
- `char>?`  : 文字の大小関係を比較する
- `char<=?` : 文字の大小関係を比較する
- `char>=?` : 文字の大小関係を比較する

### 3.7 ブーリアン型

ブーリアン型は真偽値をとるデータ型で、型は`boolean`です。
ブーリアン型は、真 (`#t`) か偽 (`#f`) のいずれかの値となります。そして、数値の比較など、条件の成否などを表すために使用します。

```racket: my-boolean.rkt
(define my-boolean #t)

```

上記の例では、変数`my-boolean`に`#t`を代入しています。
ブーリアン型には、ブーリアン型には、以下のような論理演算子が使えます。

- `not` : 否定
- `and` : 論理積
- `or`  : 論理和
- `xor` : 排他的論理和

### 3.8 シンボル型

シンボル型は、変数名や関数名などに使われる文字列で、型は`symbol`です。
シンボルは、文字列をそのまま記述します。`"`でくくりません。
その代わり、空白などの区切り文字や`#`などの文字はシンボルに使えません。」

`Racket`はシンボルが見付かると、シンボルにバインドされた値を表示します。
シンボルそのものを記述したいときは、`'`でシンボルをエスケープします。

```racket: my-simbol.rkt
(define my-symbol 'hello)

my-symbol
'hello
```

上記の例では、`my-symbol`にシンボル`hello`を代入しています。
シンボルを表示するため、先頭に`'`がついています。

### 3.9 ペア型

ペア型は、`LISP`における基本データである`cons-cell`を示すデータ型です。
`cons-cell`は 2つのデータのペアからなるデータで、最初の要素を`car`、次の要素を`cdr`と呼びます。
`Racket`では、2つのデータを`.`で区切って示します。

```racket: my-pair.rkt
(cons 1 2)
'(1 . 2)
```

上記の例は、`car`に`1`、`cdr`に`2`を代入した`cons-cell`を作成します。
図解すると:

```racket: '(1 . 2)
    +---+---+
    | 1 | 2 |
    +---+---+
```

と、なります。

### 3.10 リスト型

リスト型は、複数の要素を 1つにまとめたものです。リスト型の型は`list`です。
リストは、各要素を’<空白>'で区切って表示します。

下記は、要素 1, 2, 3 をもつリストを作成します:

```racket
(list 1 2 3)
'(1 2 3)

```

#### リスト型の構造

リストは、`cons-cell`を複数繋いだものです。各`cons-cell`の`car`部はリストの要素となるデータ、`cdr`部は次の`cons-cell`へのポイントがはいります。
最後の`cons-cell`では、`cdr`部にエンドマークとして空のリスト`'()`がはいります。

たとえば、リスト`( 1 2 3)`を図解すると:

```racket : '(1 2 3)
    +-----+------+     +-----+------+     +-----+-----+
    |  1  |  o---+---->|  2  |  o---+---->|  3  | '() |
    +-----+------+     +-----+------+     +-----+-----+

```

と、なります。

## 4. 特殊なデータ型

`Racket`では、システムが扱うための特殊なデータ型や定数があります。
このセクションでは、これらを説明します。

### 4.1 void

void型は値を持たない型で、型は`void`です。
手続きが値を返す必要がない場合に使用されます。

たとえば、下記のコード、

```racket
(define void-procedure
    (void))    ;  ←  値を返さない

```

は、手続き`void-procedure`を定義しています。`void-procedure`は値を返す必要がないので、`void`を使用しています。
`void-procedure`は値を返さないので、実行しても何も起きません。

```racket
> void-procedure
>

```

上記のように、`void-procedure`を実行すると、何も返らずプロンプトが表示されます。

### 4.2 undefined

`undefined`は、未定義の値を表現するために使用される定数です。
Racket で未定義の変数を参照しようとすると`undefined`となり、エラーが発生します。

``` racket
(define y 1)
(display (+ x y))     ;  xが未定義(undefined)なのでエラー

x: undefined;
 cannot reference an identifier before its definition
  in module: top-level
 [,bt for context]

```

## おわりに

以上で、`Racket`の基本データ型を説明しました。
つぎは、`Racket`での構文や条件分岐、関数の定義などを学習していきましょう。
`Racket`によるプログラミングの学習をすることで、関数型プログラミングについて理解していくはずです。

それでは、Happy Hacking!

## 参考資料

### 本

- [Racket Programming the Fun Way](https://www.amazon.co.jp/dp/1718500823)
- [How to Design Programs](https://www.amazon.co.jp/exec/obidos/ASIN/0262534800/)

### Web

- [Racket Documentation](https://docs.racket-lang.org/)
